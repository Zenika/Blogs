---
ID: 490
post_title: Docker 1.3 et son écosystème
author: vdemeester
post_date: 2014-10-28 11:00:00
post_excerpt: |
  <p>Le <strong>16 octobre dernier</strong>, <ins>Docker est passé en version 1.3</ins>. C'est une bonne occasion de faire un point sur ce qu'apportent les mises à jour qui sont sorties depuis la 1.0. Nous allons également en profiter pour regarder les news <strong>importantes</strong> de l'écosystème Docker.</p> <p><img src="/public/Billet_0511/docker_container_engine_logo.png" alt="Docker" title="Docker" /></p> <p>Rappel très rapide, <strong>Docker est une plate-forme ouverte à destination des développeurs et administrateurs systèmes visant à faciliter la construction et le déploiement d'applications distribuées</strong>. De manière moins marketing, l'idée derrière Docker est d'<strong>automatiser</strong> le <strong>déploiement</strong> d'environnements sous forme de <strong>conteneurs légers</strong>, portables et auto-suffisants&nbsp;; les conteneurs permettant d'isoler l'exécution des applications dans des contextes d'exécution. Pour ce faire, Docker, écris en <a href="http://golang.org/">Go</a>, reprend les bases de <strong>LXC</strong>, utilise les fonctionnalités du <strong>noyau Linux</strong> (CGroups, Namespaces, …) et se base <em>initialement</em> sur un système de fichier "en oignons" AUFS&nbsp;; D'autres backend sont supportés également comme BTRFS ou <em>devicemapper</em> (LVM).</p> <p>Depuis le 9 juin 2014 et la release de la version 1.0 "production-read", l'équipe derrière Docker n'a pas chomé et 3 nouvelles mises à jour sont sorties depuis&nbsp;; à savoir que les <em>releases</em> de Docker se font à un rythme pré-défini, "à-la" Linux, tout ce qui est prêt et testé est intégré à la release qui suit. Voyons, de façon non-exhaustive, quelles sont les princiales améliorations apportées par ces différentes versions.</p>
layout: post
permalink: http://blog.zenika-offres.com/?p=490
published: true
slide_template:
  - ""
---
<p>Le <strong>16 octobre dernier</strong>, <ins>Docker est passé en version 1.3</ins>. C'est une bonne occasion de faire un point sur ce qu'apportent les mises à jour qui sont sorties depuis la 1.0. Nous allons également en profiter pour regarder les news <strong>importantes</strong> de l'écosystème Docker.</p> <p><img src="/wp-content/uploads/2015/07/docker_container_engine_logo.png" alt="Docker" title="Docker" /></p> <p>Rappel très rapide, <strong>Docker est une plate-forme ouverte à destination des développeurs et administrateurs systèmes visant à faciliter la construction et le déploiement d'applications distribuées</strong>. De manière moins marketing, l'idée derrière Docker est d'<strong>automatiser</strong> le <strong>déploiement</strong> d'environnements sous forme de <strong>conteneurs légers</strong>, portables et auto-suffisants&nbsp;; les conteneurs permettant d'isoler l'exécution des applications dans des contextes d'exécution. Pour ce faire, Docker, écris en <a href="http://golang.org/">Go</a>, reprend les bases de <strong>LXC</strong>, utilise les fonctionnalités du <strong>noyau Linux</strong> (CGroups, Namespaces, …) et se base <em>initialement</em> sur un système de fichier "en oignons" AUFS&nbsp;; D'autres backend sont supportés également comme BTRFS ou <em>devicemapper</em> (LVM).</p> <p>Depuis le 9 juin 2014 et la release de la version 1.0 "production-read", l'équipe derrière Docker n'a pas chomé et 3 nouvelles mises à jour sont sorties depuis&nbsp;; à savoir que les <em>releases</em> de Docker se font à un rythme pré-défini, "à-la" Linux, tout ce qui est prêt et testé est intégré à la release qui suit. Voyons, de façon non-exhaustive, quelles sont les princiales améliorations apportées par ces différentes versions.</p>
<!--more-->
<h4>Hub&nbsp;: Images officielles et language stack</h4> <p>Le <strong>Hub</strong>, tel qu'il a été nommé après la sortie de Docker 1.0 est <strong>un dépôt des images Docker</strong> de tout-un-chacun qui souhaite les partager.</p> <p>Au début de l'été, Docker Inc. a annoncé l'apparition des <strong>dépots officiels</strong>. L'idée est d'estampiller des images Docker comme officielles, c'est à dire vérifiées et garanties comme étant issues et supportées par les mainteneurs des projets. De nombreuses images officielles existent déjà pour les principaux projets open-source, comme Ubuntu, MongoDB, etc. Toute communauté open-source ou même tout éditeur logiciel peut entrer en contact avec l'équipe Docker pour voir son/ses images estampillées "officielles", après validation. Cette étiquette vient se rajouter à l'étiquette "<em>automated build repository</em>", précédement appelée <em>verified</em> (ce qui prétait à confusion) qui donne la garantie à l'utilisateur que l'image a été construite de manière automatique par l'infrastructure de Docker Inc. Il est également à noter que la version 1.3.0 de Docker apporte la vérification de la provenance et de l'intégrité des images officielles via signature électronique&nbsp;; même si pour l'instant c'est en <em>work-in-progress</em>.</p> <p>Un autre ajout récent au Docker Hub, datant de fin septembre, vaut le détour&nbsp;: les l<strong>anguage stack</strong>, des images de bases <em>pre-construites</em> avec tous les outils nécessaires pour faire tourner une application dans un langage donné. Un développeur souhaitant rapidement construire un conteneur avec, par exemple, une application Clojure, n'a plus besoin de <em>réinventer la roue</em> (i.e. partir d'une image de base, installer le JDK, installer lein, etc.). Il lui suffit de partir d'une des <em>language stack</em>, ici clojure.</p> <pre class="bash code bash" style="font-family:inherit">FROM clojure COPY . <span style="color: #000000; font-weight: bold;">/</span>usr<span style="color: #000000; font-weight: bold;">/</span>src<span style="color: #000000; font-weight: bold;">/</span>app WORKDIR <span style="color: #000000; font-weight: bold;">/</span>usr<span style="color: #000000; font-weight: bold;">/</span>src<span style="color: #000000; font-weight: bold;">/</span>app CMD <span style="color: #7a0874; font-weight: bold;">&#91;</span><span style="color: #ff0000;">&quot;lein&quot;</span>, <span style="color: #ff0000;">&quot;run&quot;</span><span style="color: #7a0874; font-weight: bold;">&#93;</span></pre> <h4>Restart policies (1.2.0)</h4> <p>Docker 1.2 a apporté une option en plus à la commande <code>run</code>&nbsp;: <code>--restart</code>. Il permet de définir une <strong>politique de redémarrage</strong> dans le cas où le conteneurs viendrait à mourrir, que ce soit de manière normale (code de retour à 0) ou inattendue (<em>failure</em>, code de retour différent de 0). Trois options sont disponibles pour l'instant&nbsp;:</p> <ul> <li><strong>no</strong>&nbsp;: pas de redémarrage, fonctionnement par défaut.</li> <li><strong>on-failure</strong>: redémarrage automatique si le conteneur s'est terminé de façon anormale. Il est possible d'ajouter un nombre maximum de redémarrage&nbsp;; avec <code>--restart=on-failure:3</code> docker essaiera de redémarrer 3 fois avant d'abandonner.</li> <li><strong>always</strong>&nbsp;: redémarrage automatique, tout le temps, erreurs ou pas.</li> </ul> <h4>Injection de processus (1.3.0)</h4> <p>La possibilité de voir ce qui se passe dans le container, et par conséquent de s'en servir pour debugger, s'est averé longtemps complexe. Dans les <em>premiers jours</em> de Docker, l'installation d'un démon ssh était une solution commune. Cependant, celà complexifiait la création d'un conteneur&nbsp;; en effet, Docker est fait pour lancer et isoler une seule commande, l'ajout d'un démon sshd imposait alors de mettre en place une solution du type <em>init</em> comme supervisord, runit, ou autres. Un article de Jérôme Petazonni, employé Docker Inc, a mis les choses au point&nbsp;: <strong><a href="http://jpetazzo.github.io/2014/06/23/docker-ssh-considered-evil/">If you run SSHD in your Docker containers, you're doing it wrong!</a></strong>, littéralement "<em>Si vous faites tourner SSHD dans vos container Docker, vous vous trompez</em>". Jérôme avait créé à l'époque un outil, <a href="https://github.com/jpetazzo/nsenter">nsenter</a>, qui était (et est toujours) installable en passant par un container, histoire de montrer un peu de magie.</p> <p>La version 1.3 de Docker intègre un nouvelle commande, <code>exec</code> qui n'est autre que nsenter, en mieux, directement intégré à Docker, plus besoin de passer par un outil externe. <strong>Il devient donc possible d'executer n'importe quelle process à l'intérieur donc container, qui est en cours d'exécution</strong>. Ainsi un simple <code>docker exec -it ubuntu_bash bash</code> et nous voici dans une session bash à l'intérieur du conteneur. Bien entendu, comme pour nsenter, cela ne change pas l'idée derrière Docker qui est "une application par conteneur"&nbsp;; la commande <code>exec</code> est surtout présente pour répondre à des problématiques de <em>debug</em> et de <em>developpement</em>.</p> <h4>Cycle de vie d’un container (1.3.0)</h4> <p>Une autre nouvelle commande arrive avec la version 1.3.0 de Docker, c'est <code>create</code>. Beaucoup d'utilisateur ont demandé d'être capable de séparer la création initiale de conteneur et son lancement&nbsp;; auparavant il n'existait que la commande <code>run</code> qui faisait les deux d'un coup.</p> <pre class="bash code bash" style="font-family:inherit">$ docker create <span style="color: #660033;">-t</span> <span style="color: #660033;">-i</span> fedora <span style="color: #c20cb9; font-weight: bold;">bash</span> 6d8af538ec541dd581ebc2a24153a28329acb5268abe5ef868c1f1a261221752 $ docker start <span style="color: #660033;">-a</span> <span style="color: #660033;">-i</span> 6d8af538ec5 bash-<span style="color: #000000;">4.2</span><span style="color: #666666; font-style: italic;">#</span></pre> <h4>Options de sécurité (1.3.0)</h4> <p>Les utilisateurs de SELinux ou AppArmor vont être content, la commande <code>--security-opt</code>, arrivée avec la version 1.3.0, permet les <em>labels</em> et <em>profiles</em> de ces derniers, ce qui donne quelque chose comme&nbsp;:</p> <pre class="bash code bash" style="font-family:inherit">docker run <span style="color: #660033;">--security-opt</span> label:<span style="color: #7a0874; font-weight: bold;">type</span>:svirt_apache <span style="color: #660033;">-i</span> <span style="color: #660033;">-t</span> centos <span style="color: #c20cb9; font-weight: bold;">bash</span></pre> <p>L'avantage principal de cette nouvelle commande, c'est, sur les systèmes qui sont configurés avec SELinux ou AppArmor, de pouvoir donner des privilèges de manière plus fine qu'avec l'option <code>--privileged</code> (qui donne tout) et ainsi diminuer les risques potentiels.</p> <h4>Boot2docker</h4> <p>Docker s'appuyant sur des fonctionnalitées de noyau Linux, son usage est <em>limité</em> à un système hôte avec un noyau Linux. Le projet boot2docker vise à enlever cette barrière en <strong>permettant d'avoir la commande docker sous Mac OS X et Windows</strong>. Il s'agit ni plus ni moins d'une machine virtuelle VirtualBox légère, basée sur la distribution Tiny Core Linux, pour avoir un <em>overhead</em> le plus faible possible. L'utilisation de boot2docker n'est pas encore totalement transparente, principalement pour la gestion des ports ou encore du montage des volumes du Host (OS X ou Windows) dans le conteneur Docker. La version 1.3 de docker, et la version correspondante de boot2docker, permettent maintenant aux utiliseurs de Mac OS X de monter leur dossier <em>hôtes</em> dans le conteneur.</p> <h4>Fig 1.0</h4> <p><a href="http://www.fig.sh/">Fig</a> est un outil de développement basé sur Docker, écrit en Python. L'idée est de définir son environnement via un fichier YAML, que ce soit
pour le code sur lequel nous travaillons mais également les services externes desquels notre application dépend (Base de données, ''Message queue'', etc.).</p> <p>Nous avons donc, par exemple, un <code>Dockerfile</code>&nbsp;:</p> <pre class="bash code bash" style="font-family:inherit">FROM clojure:lein-2.5.0 ADD . <span style="color: #000000; font-weight: bold;">/</span>code WORKDIR <span style="color: #000000; font-weight: bold;">/</span>code RUN lein run</pre> <p>Et un <code>fig.yml</code>&nbsp;:</p> <pre>[yaml] web:   build: .   command: lein run   links:    - db   ports:    - &quot;8000:8000&quot; db:   image: postgres </pre> <p>Enfin un petit <code>fig up</code> et c'est gagné, nous obtenons notre base de données relationnelle qui tourne, notre appli qui a été construite et qui tourne aussi, et qui est lié à notre conteneur db. Il existe bien d'autres commandes (<code>start</code>, <code>stop</code>, <code>destroy</code>, etc.).</p> <p>Fig était initialement développé par <a href="https://www.orchardup.com/">Orchard</a>, qui a été acquis cette année par Docker Inc. Ce 17 octobre, l'équipe Docker a donc fait un release 1.0 de Fig en ajoutant le support à docker 1.3 et à boot2docker. Un certain nombre de commandes et de nouvelles fonctionnalitées ont étés ajoutées, notament&nbsp;:</p> <ul> <li><code>fig port</code>, qui liste les ports par service,</li> <li><code>fig pull</code>, qui récupère la dernière version d'un service,</li> <li><code>fig restart</code>, qui redémarre les conteneurs (<code>stop</code> et <code>start</code>)</li> <li>le support de <code>.dockerignore</code></li> <li>le support de connection en TLS au daemon Docker</li> <li>et pas mal d'autres options.</li> </ul> <p>Mais l'annonce principale accompagnant cette version est que <strong>Fig ne recevra plus de mise à jour majeure à partir de cette version 1.0</strong> puisque l'équipe Docker travaille pour <strong>intégrer les fonctionnalités</strong> que Fig apporte, <strong>directement dans Docker</strong>&nbsp;; ce qui est une excellente nouvelle.</p> <h4>Partenariat avec Microsoft</h4> <p>Cela transpirait ces derniers mois, dans les différentes conférences et meetups, Microsoft s'intéressait de très prêt à Docker. C'est maintenant officiel, <strong>Docker Inc et Microsoft sont partenaires</strong>. Le partenariat couvre pour l'instant les sujets suivants&nbsp;:</p> <ul> <li>Ajouter le support de windows comme hôte Docker.</li> <li>Pour Microsoft, supporter les API <em>open-orchestration</em> de Docker.</li> <li>Intégration de Docker dans Microsoft Azure.</li> <li>Collaboration étroite sur les applications qui ont besoin de plusieurs conteneur (i.e. ce que Fig fait de mieux), et le support d'application qui sont composés de conteneurs Linux et Windows.</li> </ul> <p>Le but <em>ultime</em> de Docker quand il a été distribué de façon libre était&nbsp;: "__Construire le 'bouton' qui permet à toutes applications d'être construites et déployées sur n'importe quel serveur, n'importe où.__" (C'est nettement plus classe en anglais&nbsp;: “''To build the ‘button’ that enables any application to be built and deployed on any server, anywhere.''”). Ce partenariat est donc une nouvelle marche en direction de ce dernier.</p> <h4>Conclusion</h4> <p>Un an et demi après la première <em>release</em> publique de Docker et près de 5 mois après la version 1.0, Docker et sa communauté avancent toujours aussi vite. Comme Solomon Hykes (CTO et co-fondateur de dotCould) avait dit lors de la dockerCon 14&nbsp;: "<strong>la valeur réelle de docker n'est pas la technologie, mais le fait que les gens se mettent d'accord sur quelque chose</strong>"&nbsp;; Docker Inc. pousse principalement dans le sens de la standardisation. Le développement de <a href="https://github.com/docker/libcontainer">libcontainer</a>, <a href="https://github.com/docker/libchan">libchan</a> et <a href="https://github.com/docker/libswarm">libswarm</a> sont des projets qui vont dans ce sens. La communautée est toute aussi <em>bouillante</em> d'idées et chaque jour voit de nouveau projet plus intéressant les uns que les autres.</p> <p>Enfin la <strong><a href="http://europe.dockercon.com/">dockerCon Europe</a>, les 4 et 5 décembre 2014</strong> viendra couronner une année très riche du côté de Docker et de son écosystème. Rendez-vous mi-décembre pour faire un petit retour sur la première conférence européenne Docker ;-).</p>